{"version":3,"file":"scribe-plugin-curly-quotes.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../src/plugins/scribe-plugin-curly-quotes.js"],"sourcesContent":["define('scribe-plugin-curly-quotes',[],function () {\n\n  'use strict';\n\n  return function () {\n\n    var keys = {\n      34: '\"',\n      39: '\\''\n    };\n\n    var openDoubleCurly = '“';\n    var closeDoubleCurly = '”';\n\n    var openSingleCurly = '‘';\n    var closeSingleCurly = '’';\n\n    var NON_BREAKING_SPACE = '\\u00A0';\n\n    return function (scribe) {\n      // Substitute quotes while typing\n      scribe.el.addEventListener('keypress', input);\n\n      // Substitute quotes on setting content or paste\n      scribe.htmlFormatter.formatters.push(substituteCurlyQuotes);\n\n      function input(event) {\n        var curlyChar;\n\n        // If previous char is real content, close quote; else, open\n        // TODO: annoying Chrome/Firefox\n        var currentChar = keys[event.charCode];\n        if (currentChar === '\"') {\n          if (wordBeforeSelectedRange()) {\n            curlyChar = closeDoubleCurly;\n          } else {\n            curlyChar = openDoubleCurly;\n          }\n        } else if (currentChar === '\\'') {\n          if (wordBeforeSelectedRange()) {\n            curlyChar = closeSingleCurly;\n          } else {\n            curlyChar = openSingleCurly;\n          }\n        }\n\n        // Substitute entered char with curly replacement\n        if (curlyChar) {\n          event.preventDefault();\n\n          scribe.transactionManager.run(function() {\n            var quoteText = replaceSelectedRangeWith(curlyChar);\n            placeCaretAfter(quoteText);\n          });\n        }\n      }\n\n      function wordBeforeSelectedRange() {\n        var prevChar = charBeforeSelectedRange() || '';\n        return isWordCharacter(prevChar);\n      }\n\n      function charBeforeSelectedRange() {\n        var selection = new scribe.api.Selection();\n        var context = selection.range.commonAncestorContainer.textContent;\n        return context[selection.range.startOffset - 1];\n      }\n\n      function charAfterSelectedRange() {\n        var selection = new scribe.api.Selection();\n        var context = selection.range.commonAncestorContainer.textContent;\n        return context[selection.range.endOffset];\n      }\n\n      function isWordCharacter(character) {\n          return /[^\\s()]/.test(character);\n      }\n\n      /** Delete any selected text, insert text instead */\n      function replaceSelectedRangeWith(text) {\n        var textNode = document.createTextNode(text);\n\n        var selection = new scribe.api.Selection();\n        selection.range.deleteContents();\n        selection.range.insertNode(textNode);\n\n        return textNode;\n      }\n\n      function placeCaretAfter(node) {\n        var rangeAfter = document.createRange();\n        rangeAfter.setStartAfter(node);\n        rangeAfter.setEndAfter(node);\n\n        var selection = new scribe.api.Selection();\n        selection.selection.removeAllRanges();\n        selection.selection.addRange(rangeAfter);\n      }\n\n      function substituteCurlyQuotes(html) {\n        // We don't want to replace quotes within the HTML markup\n        // (e.g. attributes), only to text nodes\n        var holder = document.createElement('div');\n        holder.innerHTML = html;\n\n        // Replace straight single and double quotes with curly\n        // equivalent in the given string\n        mapTextNodes(holder, function(str) {\n          // Tokenise HTML elements vs text between them\n          // Note: this is escaped HTML in the text node!\n          var tokens = str.split(/(<[^>]+?>)/);\n          return tokens.map(function(token) {\n            // Only replace quotes in text between (potential) HTML elements\n            if (token[0] === '<') {\n              return token;\n            } else {\n              return token.\n                // Use [\\s\\S] instead of . to match any characters _including newlines_\n                replace(/([\\s\\S])?'([\\s\\S])?/g,\n                        replaceQuotesFromContext(openSingleCurly, closeSingleCurly)).\n                replace(/([\\s\\S])?\"([\\s\\S])?/g,\n                        replaceQuotesFromContext(openDoubleCurly, closeDoubleCurly));\n            }\n          }).join('');\n        });\n\n        return holder.innerHTML;\n      }\n\n      function replaceQuotesFromContext(openCurly, closeCurly) {\n        return function(m, prev, next) {\n          prev = prev || '';\n          next = next || '';\n          var isStart = ! prev;\n          var isEnd = ! next;\n          var hasCharsBefore = isWordCharacter(prev);\n          var hasCharsAfter  = isWordCharacter(next);\n          // Optimistic heuristic, would need to look at DOM structure\n          // (esp block vs inline elements) for more robust inference\n          if (hasCharsBefore || (isStart && ! hasCharsAfter && ! isEnd)) {\n            return prev + closeCurly + next;\n          } else {\n            return prev + openCurly + next;\n          }\n        };\n      }\n\n      // Apply a function on all text nodes in a container, mutating in place\n      function mapTextNodes(container, func) {\n        var walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);\n        var node = walker.firstChild();\n        if (node) {\n          do {\n            node.data = func(node.data);\n          } while ((node = walker.nextSibling()));\n        }\n\n        return node;\n      }\n\n    };\n  };\n\n});\n\n"],"names":[]}